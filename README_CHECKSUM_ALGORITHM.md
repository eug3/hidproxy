# HID设备校验和生成算法文档

## 概述

本文档描述了HID设备33字符校验和的完整生成算法，该算法通过逆向分析获得。

## 卡片数据存储位置

### 扇区0（UID存储）
- **块0**: 存储卡片UID（唯一标识符）
- **数据格式**: 4字节UID + 制造商数据
- **用途**: 卡片硬件唯一标识，不可修改

### 扇区1（用户数据和校验和）
该扇区存储用户信息和校验和数据。

#### 数据结构

| 字段 | 内容示例 | 说明 |
|------|----------|------|
| 姓名 | 韩蓉韩蓉 | 用户姓名（中文） |
| 年检信息1 | 2025年度于2025-01-17 17:38:24 | 第一年年检信息 |
| 年检信息2 | 2026年度于2026-01-17 17:38:25 | 第二年年检信息 |
| 状态 | 已备案-在用 | 设备状态 |
| **校验和** | **02F4DE5D2F70DF1F86CA3B690BF304B44** | **33字符校验和（关键字段）** |
| 单位 | 江苏华信资产评估有限公司 | 所属单位 |

#### 扇区1字段位置和长度

**重要**: 在更新卡片数据时，必须保持字段的位置和长度不变。

| 字段名 | 起始位置 | 长度 | 说明 |
|--------|----------|------|------|
| 姓名 | 块0, 偏移0 | 可变 | Unicode编码 |
| 年检信息1 | 块0, 偏移X | ~40字节 | "YYYY年度于YYYY-MM-DD HH:MM:SS" |
| 年检信息2 | 块1, 偏移0 | ~40字节 | "YYYY年度于YYYY-MM-DD HH:MM:SS" |
| 状态 | 块1, 偏移X | 可变 | 中文状态字符串 |
| **校验和** | **块2, 偏移0** | **33字节** | **ASCII字符串，固定33字符** |
| 单位 | 块2, 偏移33 | 可变 | 单位名称 |

#### 更新操作注意事项

1. **校验和位置**: 固定在扇区1的特定位置
2. **字段长度**: 校验和必须保持33个字符
3. **编码格式**: ASCII字符（0-9, A-F）
4. **更新流程**:
   - 读取扇区1当前数据
   - 定位校验和字段位置
   - 替换33字节校验和数据
   - 保持其他字段不变
   - 写回扇区1

## 算法说明

### 输入参数

- **UID** (User ID): 10位数字，用户唯一标识符
- **HID** (Hardware ID): 9位数字，硬件设备ID
- **年份值**: 4位年份数字
  - 已年检设备：使用特定年份（如2022）
  - 未年检设备：使用当前系统年份（如2025）

### 算法步骤

1. **构建MD5输入字符串**
   ```
   输入格式: "1" + UID + "1" + "2" + HID + 年份
   ```
   - 第1个字符: 固定分隔符 `"1"`
   - 第2-11个字符: UID (10位数字)
   - 第12个字符: 固定分隔符 `"1"`
   - 第13个字符: 固定字符 `"2"`
   - 第14-22个字符: HID (9位数字)
   - 第23-26个字符: 年份 (4位数字)
   
   总长度: 26个字符

2. **计算MD5哈希值**
   ```
   MD5哈希 = MD5(输入字符串).upper()
   ```
   - 对输入字符串进行MD5计算
   - 将结果转换为大写32位十六进制字符串

3. **生成最终校验和**
   ```
   校验和 = "0" + MD5哈希
   ```
   - 在MD5哈希值前添加字符 `"0"`
   - 最终结果为33个字符

## Python实现

```python
import hashlib

def generate_checksum(uid, hid, year_value):
    """
    生成HID设备33字符校验和
    
    参数:
        uid (int): 用户ID，10位数字
        hid (int): 硬件设备ID，9位数字
        year_value (int): 年份值
    
    返回:
        str: 33字符校验和字符串
    
    示例:
        >>> generate_checksum(1264495731, 765674391, 2022)
        '06C6CA0E94C835E38817A66A9315141F7'
    """
    # 1. 构建MD5输入字符串
    input_str = f"1{uid}12{hid}{year_value}"
    
    # 2. 计算MD5哈希值
    md5_hash = hashlib.md5(input_str.encode()).hexdigest().upper()
    
    # 3. 生成最终校验和
    checksum = "0" + md5_hash
    
    return checksum


def generate_checksum_current_year(uid, hid):
    """
    使用当前年份生成校验和（未年检设备）
    
    参数:
        uid (int): 用户ID
        hid (int): 硬件设备ID
    
    返回:
        str: 33字符校验和字符串
    """
    from datetime import datetime
    current_year = datetime.now().year
    return generate_checksum(uid, hid, current_year)


def generate_checksum_verified(uid, hid, verification_year):
    """
    使用指定年检年份生成校验和（已年检设备）
    
    参数:
        uid (int): 用户ID
        hid (int): 硬件设备ID
        verification_year (int): 年检年份
    
    返回:
        str: 33字符校验和字符串
    """
    return generate_checksum(uid, hid, verification_year)
```

## 验证示例

### 示例1: 已年检设备（年份2022）

**输入:**
- UID: `1264495731`
- HID: `765674391`
- 年份: `2022`

**计算过程:**
1. 拼接字符串: `"11264495731127656743912022"`
2. MD5计算: `"6C6CA0E94C835E38817A66A9315141F7"`
3. 最终校验和: `"06C6CA0E94C835E38817A66A9315141F7"`

**验证:**
```python
>>> generate_checksum(1264495731, 765674391, 2022)
'06C6CA0E94C835E38817A66A9315141F7'
```
✅ 验证成功

### 示例2: 未年检设备（年份2025）

**输入:**
- UID: `1264495731`
- HID: `765674391`
- 年份: `2025` (当前系统年份)

**计算过程:**
1. 拼接字符串: `"11264495731127656743912025"`
2. MD5计算: `"2F4DE5D2F70DF1F86CA3B690BF304B44"`
3. 最终校验和: `"02F4DE5D2F70DF1F86CA3B690BF304B44"`

**验证:**
```python
>>> generate_checksum(1264495731, 765674391, 2025)
'02F4DE5D2F70DF1F86CA3B690BF304B44'
```
✅ 验证成功

## 字段说明

### 固定字段

| 位置 | 字段 | 说明 |
|------|------|------|
| 第1位 | `"1"` | 固定分隔符 |
| 第12位 | `"1"` | 固定分隔符 |
| 第13位 | `"2"` | 固定标识符 |
| 第1位（最终） | `"0"` | 校验和前缀 |

### 可变字段

| 位置 | 字段 | 长度 | 说明 |
|------|------|------|------|
| 第2-11位 | UID | 10位 | 用户唯一标识符 |
| 第14-22位 | HID | 9位 | 硬件设备ID |
| 第23-26位 | 年份 | 4位 | 年份值（年检年份或当前年份） |

## 年份字段规则

根据设备年检状态，年份字段使用不同的值：

- **未年检设备**: 使用当前系统年份（例如：2025）
- **已年检设备**: 使用年检相关年份（例如：2022，可能是首次年检年份、有效期起始年份等）

## 核心函数位置（逆向分析）

通过IDA Pro逆向分析定位的关键函数：

| 函数地址 | 函数名称 | 功能描述 |
|----------|----------|----------|
| `0x72D3C0` | `sub_72D3C0` | 校验和生成核心函数 |
| `0x4055C0` | `sub_4055C0` | 字符串拼接函数（拼接输入字符串） |
| `0x710B90` | `sub_710B90` | MD5计算函数 |
| `0x710C00` | `sub_710C00` | MD5转十六进制字符串 |

## 技术细节

### MD5输入字符串构造

输入字符串由以下部分按顺序拼接而成：

```
字段1: "1"          (1字符)
字段2: UID          (10字符)
字段3: "1"          (1字符)
字段4: "2"          (1字符)
字段5: HID          (9字符)
字段6: 年份         (4字符)
---------------------------------
总计:               (26字符)
```

### MD5计算

- 算法: 标准MD5
- 输入: 26字符ASCII字符串
- 输出: 16字节二进制数据
- 编码: 转换为32字符大写十六进制字符串

### 校验和格式

- 前缀: `"0"`
- MD5哈希: 32个大写十六进制字符
- 总长度: 33个字符
- 示例: `06C6CA0E94C835E38817A66A9315141F7`

## 使用注意事项

1. **UID和HID必须精确**: 这两个值是设备的唯一标识，任何差异都会导致校验和不匹配
2. **年份值的选择**: 根据设备年检状态选择正确的年份值
3. **大小写敏感**: 最终输出的MD5必须是大写字母
4. **字符编码**: 输入字符串使用ASCII编码

## 测试用例

```python
import hashlib

def test_checksum_algorithm():
    """测试校验和算法"""
    
    # 测试用例1: 已年检设备
    assert generate_checksum(1264495731, 765674391, 2022) == \
           "06C6CA0E94C835E38817A66A9315141F7"
    
    # 测试用例2: 未年检设备
    assert generate_checksum(1264495731, 765674391, 2025) == \
           "02F4DE5D2F70DF1F86CA3B690BF304B44"
    
    print("✅ 所有测试通过")

if __name__ == "__main__":
    test_checksum_algorithm()
```

## 完整示例代码

```python
import hashlib
from datetime import datetime

def generate_checksum(uid, hid, year_value):
    """生成HID设备校验和"""
    input_str = f"1{uid}12{hid}{year_value}"
    md5_hash = hashlib.md5(input_str.encode()).hexdigest().upper()
    return "0" + md5_hash

# 示例1: 未年检设备（使用当前年份）
uid = 1264495731
hid = 765674391
current_year = datetime.now().year  # 2025

checksum_unverified = generate_checksum(uid, hid, current_year)
print(f"未年检设备校验和: {checksum_unverified}")
# 输出: 02F4DE5D2F70DF1F86CA3B690BF304B44

# 示例2: 已年检设备（使用年检年份）
verification_year = 2022

checksum_verified = generate_checksum(uid, hid, verification_year)
print(f"已年检设备校验和: {checksum_verified}")
# 输出: 06C6CA0E94C835E38817A66A9315141F7
```

## 版本历史

- **v1.0** (2025-01-14): 初始版本，完整算法验证通过

## 许可证

本文档仅供学习和研究使用。
